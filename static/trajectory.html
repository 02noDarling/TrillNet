<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>轨迹展示</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/static/lib/leaflet/leaflet.css" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* html, body, #map { height: 100%; margin: 0; } */
    html, body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* 防止滚动条导致空白 */
    }
    #map {
        height: 100vh;   /* 使用视口高度 */
        width: 100vw;    /* 使用视口宽度 */
        position: fixed; /* 固定定位消除边距 */
        left: 0;
        top: 0;
    }
    #panel {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 10px;
      width: 280px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
    }
    textarea { width: 100%; height: 100px; margin-bottom: 8px; }
    button {
      margin: 2px;
      padding: 4px 8px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background-color: #45a049; }
    h4 {
      margin-top: 16px;
      margin-bottom: 8px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 4px;
    }
    .error-message {
      color: red;
      font-size: 14px;
      margin-top: 5px;
    }
  </style>
</head>
<body class="bg-gray-100 h-screen">
<!-- <div id="panel">
  <button onclick="window.location.href='experiment_ui'">返回实验列表</button>
  <button onclick="toggleHistoryTrajectory()">显示/隐藏历史轨迹</button>
  <h4>编辑当前轨迹</h4>
  <textarea id="currentTrajectoryInput" placeholder="请输入ID列表，用逗号隔开，如：1,2,-1,4"></textarea>
  <button onclick="submitCurrentTrajectory()">提交当前轨迹</button>
  <button onclick="completeCurrentTrajectory()">补全当前轨迹</button>
  <button onclick="removeCurrentTrajectory()">删除当前轨迹</button>
  <button onclick="simulateTrajectory()">模拟轨迹</button>
  <button onclick="saveTrajectory()">保存轨迹</button>
  <div id="currentError" class="error-message"></div>
</div>
<div id="map"></div> -->
<div id="trajectory-recovery-page" class="h-full">
  <div class="absolute top-4 left-4 z-[1000] bg-white p-4 rounded-lg shadow-lg w-80">
    <button onclick="window.location.href='experiment_ui'" class="mb-2 w-full bg-gray-500 text-white p-2 rounded hover:bg-gray-600">返回</button>
    <button onclick="toggleHistoryTrajectory()" class="mb-2 w-full bg-gray-500 text-white p-2 rounded hover:bg-gray-600">显示历史轨迹</button>
    <h4 class="text-lg font-bold mb-2 border-b pb-2">编辑当前轨迹</h4>
    <textarea id="currentTrajectoryInput" class="w-full h-24 mb-2 p-2 border rounded" placeholder="请输入ID列表，用逗号隔开，如：1,2,-1,4"></textarea>
    <button onclick="submitCurrentTrajectory()" class="mb-2 w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600">提交当前轨迹</button>
    <button onclick="completeCurrentTrajectory()" class="mb-2 w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600">补全当前轨迹</button>
    <button onclick="removeCurrentTrajectory()" class="mb-2 w-full bg-red-500 text-white p-2 rounded hover:bg-red-600">删除当前轨迹</button>
    <button onclick="simulateTrajectory()" class="mb-2 w-full bg-green-500 text-white p-2 rounded hover:bg-green-600">模拟轨迹</button>
    <button onclick="saveTrajectory()" class="mb-2 w-full bg-purple-500 text-white p-2 rounded hover:bg-purple-600">保存轨迹</button>
    <div id="currentError" class="text-red-500 text-sm mt-2"></div>
  </div>
  <div id="map"></div>
</div>

<script src="/static/lib/leaflet/leaflet.js"></script>
<script>
  // 在页面加载时获取实验ID
  const urlParams = new URLSearchParams(window.location.search)
  const expId = urlParams.get('expId')

  let map;
  try {
    map = L.map('map', {
      zoomControl: false,
      center: [39.925, 116.375],
      zoom: 13,
      minZoom: 11,
      maxZoom: 18,
      maxBounds: [[39.75, 116.15], [40.1, 116.6]],
      maxBoundsViscosity: 1.0
    });
    // L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
    L.tileLayer('/tiles/{z}/{x}/{y}.png', {
        attribution: '本地地图数据',
        maxZoom: 18  // 与下载的瓦片最大层级一致
    }).addTo(map);
  } catch (error) {
    console.error("地图初始化失败:", error);
    alert("无法初始化地图，请检查网络或代码");
  }
  

  let historyVisible = false;
  let historyLayers = [];
  let currentTrajectoryLayer = null;
  let currentTrajectoryArrows = [];
  let currentTrajectoryMarkers = [];
  let currentPoints = [];
  let currentIds = [];
  window.currentMarker = null;
  window.animationFrameId = null;
  window.isAnimating = false;

  const historyColors = ['blue', 'green', 'purple', 'orange', 'brown', 'cyan'];

  function toggleHistoryTrajectory() {
    if (historyVisible) {
      historyLayers.forEach(layer => map.removeLayer(layer));
      historyLayers = [];
    } else {
      fetch('http://localhost:5000/get_history', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ expId: expId }),
        credentials: 'include'
      })
      // fetch("http://localhost:5000/get_history")
        .then(res => {
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          return res.json();
        })
        .then(data => {
          console.log("获取的历史轨迹:", data);
          const trajectories = data.trajectories || [];
          let allBounds = [];
          trajectories.forEach((trajectory, index) => {
            const color = historyColors[index % historyColors.length];
            let validPoints = [];
            trajectory.forEach((point, i) => {
              if (point !== null) {
                validPoints.push(point);
                const marker = L.circleMarker(point, {
                  radius: 3,
                  color: color,
                  fillColor: color,
                  fillOpacity: 0.8
                }).addTo(map);
                historyLayers.push(marker);
              } else if (validPoints.length > 0) {
                const polyline = L.polyline(validPoints, { color: color, weight: 4 }).addTo(map);
                historyLayers.push(polyline);
                validPoints = [];
              }
            });
            if (validPoints.length > 0) {
              const polyline = L.polyline(validPoints, { color: color, weight: 4 }).addTo(map);
              historyLayers.push(polyline);
              allBounds.push(...validPoints);
            }
          });
          if (allBounds.length > 0) {
            map.fitBounds(L.latLngBounds(allBounds));
          } else {
            // showError("currentError", "没有可显示的历史轨迹");
          }
        })
        .catch(error => {
          console.error("获取历史轨迹错误:", error);
          showError("currentError", "无法加载历史轨迹，请检查服务器");
        });
    }
    historyVisible = !historyVisible;
  }

  function showError(elementId, message) {
    const errorElement = document.getElementById(elementId);
    errorElement.textContent = message;
    setTimeout(() => errorElement.textContent = '', 3000);
  }

  function addArrows(points, ids, color) {
    console.log("添加箭头，points:", points, "ids:", ids, "color:", color);
    if (!points || points.length < 2 || !ids) {
      console.warn("无效的 points 或 ids，无法添加箭头");
      return;
    }
    for (let i = 0; i < points.length - 1; i++) {
      const startPoint = points[i];
      const endPoint = points[i + 1];
      if (!startPoint || !endPoint) {
        console.log(`跳过箭头 [${i}]: start=${startPoint}, end=${endPoint}, ids=${ids[i]},${ids[i+1]}`);
        console.log(typeof startPoint);
        continue;
      }
      const angle = getAngle(startPoint, endPoint);
      console.log(`箭头 [${i}]: start=${startPoint}, end=${endPoint}, angle=${angle}`);
      const arrowIcon = L.divIcon({
        className: '',
        html: `<div style="width: 10px; height: 10px; background-color: purple; transform: rotate(45deg) rotate(${angle}deg);"></div>`,
        iconSize: [15, 15],
        iconAnchor: [7.5, 7.5]
      });
      console.log("有箭头了");
      console.log(angle);
      const arrowMarker = L.marker(endPoint, { icon: arrowIcon }).addTo(map);
      currentTrajectoryArrows.push(arrowMarker);
    }
  }

  function getAngle(start, end) {
    if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || start.length < 2 || end.length < 2) {
      console.warn("无效的 start 或 end 坐标:", start, end);
      return 0;
    }
    const startPixel = map.latLngToLayerPoint([start[0], start[1]]);
    const endPixel = map.latLngToLayerPoint([end[0], end[1]]);
    if (!startPixel || !endPixel || isNaN(startPixel.x) || isNaN(startPixel.y) || isNaN(endPixel.x) || isNaN(endPixel.y)) {
      console.warn("无效的像素坐标:", startPixel, endPixel);
      return 0;
    }
    const dx = endPixel.x - startPixel.x;
    const dy = endPixel.y - startPixel.y;
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }

  function removeArrowsAndMarkers() {
    currentTrajectoryArrows.forEach(marker => {
      if (marker && typeof marker.remove === 'function') {
        marker.remove();
      }
    });
    currentTrajectoryMarkers.forEach(marker => {
      if (marker && typeof marker.remove === 'function') {
        marker.remove();
      }
    });
    currentTrajectoryArrows = [];
    currentTrajectoryMarkers = [];
  }

  function submitCurrentTrajectory() {
    const input = document.getElementById("currentTrajectoryInput").value;
    if (!input.trim()) {
      showError("currentError", "请输入轨迹数据");
      return;
    }
    const idList = input.split(",").map(s => {
      const val = parseFloat(s.trim());
      return isNaN(val) ? -1 : val;
    });
    if (idList.length === 0) {
      showError("currentError", "轨迹数据无效");
      return;
    }

    fetch("http://localhost:5000/convert_trajectory", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ trajectory: idList })
    })
      .then(res => {
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        return res.json();
      })
      .then(data => {
        console.log("提交当前轨迹数据:", data);
        const points = data.points.map(p => p.coord);
        if (currentTrajectoryLayer) {
          currentTrajectoryLayer.remove();
          currentTrajectoryLayer = null;
        }
        removeArrowsAndMarkers();

        const layers = [];
        let polylinePoints = [];
        points.forEach((point, i) => {
          if (point !== null) {
            polylinePoints.push(point);
            const marker = L.circleMarker(point, {
              radius: 4,
              color: 'red',
              fillColor: 'red',
              fillOpacity: 0.8,
              draggable: true
            }).addTo(map).on('dragend', function(e) {
              const newLatLng = e.target.getLatLng();
              points[i] = [newLatLng.lat, newLatLng.lng];
              updateCurrentTrajectory(points, idList);
            });
            currentTrajectoryMarkers.push(marker);
          } else if (polylinePoints.length > 0) {
            const polyline = L.polyline(polylinePoints, { color: 'red', weight: 4, dashArray: '5, 5' }).addTo(map);
            layers.push(polyline);
            polylinePoints = [];
          }
        });

        if (polylinePoints.length > 0) {
          const polyline = L.polyline(polylinePoints, { color: 'red', weight: 4, dashArray: '5, 5' }).addTo(map);
          layers.push(polyline);
        }

        if (layers.length > 0) {
          currentTrajectoryLayer = L.layerGroup(layers).addTo(map);
        }

        addArrows(points, idList, 'red');
        currentPoints = points;
        currentIds = idList;

        if (points.filter(p => p !== null).length > 0) {
          map.fitBounds(L.polyline(points.filter(p => p !== null)).getBounds());
        }
      })
      .catch(error => {
        console.error("提交当前轨迹错误:", error);
        showError("currentError", "提交轨迹失败，请检查服务器");
      });
  }

  function updateCurrentTrajectory(points, ids) {
    if (currentTrajectoryLayer) {
      currentTrajectoryLayer.remove();
      currentTrajectoryLayer = null;
    }
    removeArrowsAndMarkers();

    const layers = [];
    let polylinePoints = [];
    points.forEach((point, i) => {
      if (point !== null) {
        polylinePoints.push(point);
        const marker = L.circleMarker(point, {
          radius: 4,
          color: 'red',
          fillColor: 'red',
          fillOpacity: 0.8,
          draggable: true
        }).addTo(map).on('dragend', function(e) {
          const newLatLng = e.target.getLatLng();
          points[i] = [newLatLng.lat, newLatLng.lng];
          updateCurrentTrajectory(points, ids);
        });
        currentTrajectoryMarkers.push(marker);
      } else if (polylinePoints.length > 0) {
        const polyline = L.polyline(polylinePoints, { color: 'red', weight: 4, dashArray: '5, 5' }).addTo(map);
        layers.push(polyline);
        polylinePoints = [];
      }
    });

    if (polylinePoints.length > 0) {
      const polyline = L.polyline(polylinePoints, { color: 'red', weight: 4, dashArray: '5, 5' }).addTo(map);
      layers.push(polyline);
    }

    if (layers.length > 0) {
      currentTrajectoryLayer = L.layerGroup(layers).addTo(map);
    }

    addArrows(points, ids, 'red');
    currentPoints = points;
    currentIds = ids;
  }

  function completeCurrentTrajectory() {
    const input = document.getElementById("currentTrajectoryInput").value;
    if (!input.trim()) {
      showError("currentError", "请先输入轨迹数据");
      return;
    }
    const idList = input.split(",").map(s => {
      const val = parseFloat(s.trim());
      return isNaN(val) ? -1 : val;
    });
    if (!idList.includes(-1)) {
      showError("currentError", "轨迹不包含缺失点(-1)");
      return;
    }

    fetch("http://localhost:5000/complete_trajectory", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ 
        trajectory: idList,
        expId: expId
      })
    })
      .then(res => {
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        return res.json();
      })
      .then(data => {
        console.log("补全轨迹数据:", data);
        const points = data.points;
        if (currentTrajectoryLayer) {
          currentTrajectoryLayer.remove();
          currentTrajectoryLayer = null;
        }
        removeArrowsAndMarkers();

        const layers = [];
        let polylinePoints = [];
        points.forEach((point, i) => {
          if (point.coord !== null) {
            polylinePoints.push(point.coord);
            const radius = point.inferred ? 8 : 4;
            const color = point.inferred ? 'black' : 'red';
            const marker = L.circleMarker(point.coord, {
              radius: radius,
              color: color,
              fillColor: color,
              fillOpacity: 0.8,
              draggable: true
            }).addTo(map).on('dragend', function(e) {
              const newLatLng = e.target.getLatLng();
              points[i].coord = [newLatLng.lat, newLatLng.lng];
              updateCurrentTrajectory(points.map(p => p.coord), idList);
            });
            currentTrajectoryMarkers.push(marker);
          } else if (polylinePoints.length > 0) {
            const polyline = L.polyline(polylinePoints, { color: 'red', weight: 4, dashArray: '5, 5' }).addTo(map);
            layers.push(polyline);
            polylinePoints = [];
          }
        });

        if (polylinePoints.length > 0) {
          const polyline = L.polyline(polylinePoints, { color: 'red', weight: 4, dashArray: '5, 5' }).addTo(map);
          layers.push(polyline);
        }

        if (layers.length > 0) {
          currentTrajectoryLayer = L.layerGroup(layers).addTo(map);
        }

        addArrows(points.map(p => p.coord), idList, 'red');
        currentPoints = points.map(p => p.coord);
        currentIds = idList;

        if (points.filter(p => p.coord !== null).length > 0) {
          map.fitBounds(L.polyline(points.map(p => p.coord).filter(p => p !== null)).getBounds());
        }
      })
      .catch(error => {
        console.error("补全轨迹错误:", error);
        showError("currentError", "补全轨迹失败，请检查服务器");
      });
  }

  function removeCurrentTrajectory() {
    console.log("删除当前轨迹，当前状态:", {
      hasLayer: !!currentTrajectoryLayer,
      arrowCount: currentTrajectoryArrows.length,
      markerCount: currentTrajectoryMarkers.length
    });
    if (currentTrajectoryLayer) {
      currentTrajectoryLayer.remove();
      currentTrajectoryLayer = null;
    }
    removeArrowsAndMarkers();
    document.getElementById("currentTrajectoryInput").value = "";
    currentPoints = [];
    currentIds = [];
    if (window.currentMarker) {
      window.currentMarker.remove();
      window.currentMarker = null;
    }
    if (window.animationFrameId) {
      cancelAnimationFrame(window.animationFrameId);
      window.animationFrameId = null;
    }
    window.isAnimating = false;
    console.log("删除完成");
  }

  function simulateTrajectory() {
    if (!currentPoints || currentPoints.length < 2) {
      showError("currentError", "请先提交或补全轨迹，至少包含两个点");
      return;
    }

    let validPoints = currentPoints.filter(p => p !== null && Array.isArray(p) && p.length === 2);
    if (validPoints.length < 2) {
      showError("currentError", "有效轨迹点不足，至少需要两个");
      return;
    }

    // 停止当前动画并清理
    if (window.isAnimating) {
      console.log("停止当前动画");
      if (window.currentMarker) {
        window.currentMarker.remove();
        window.currentMarker = null;
      }
      if (window.animationFrameId) {
        cancelAnimationFrame(window.animationFrameId);
        window.animationFrameId = null;
      }
    }
    window.isAnimating = true;
    let index = 0;

    function moveMarker() {
      if (index >= validPoints.length) {
        if (window.currentMarker) {
          window.currentMarker.remove();
          window.currentMarker = null;
        }
        window.isAnimating = false;
        window.animationFrameId = null;
        return;
      }

      const startPoint = L.latLng(validPoints[index]);
      const endPoint = L.latLng(validPoints[index + 1] || validPoints[index]);
      const angle = getAngle([startPoint.lat, startPoint.lng], [endPoint.lat, endPoint.lng]);

      if (!window.currentMarker) {
        const navIcon = L.divIcon({
          className: '',
          html: `
            <div style="position: relative; width: 15px; height: 15px;">
              <div style="width: 15px; height: 15px; border: 3px solid green; border-radius: 50%; background-color: transparent; position: absolute; top: 0; left: 50%; transform: translateX(-50%);"></div>
              <div style="width: 0; height: 0; border-left: 7.5px solid transparent; border-right: 7.5px solid transparent; border-top: 15px solid green; position: absolute; top: 15px; left: 50%; transform: translateX(-50%) rotate(${angle}deg);"></div>
            </div>
          `,
          iconSize: [22.5, 30],
          iconAnchor: [11.25, 30]
        });
        window.currentMarker = L.marker(startPoint, { icon: navIcon }).addTo(map);
      }

      if (index < validPoints.length - 1) {
        const start = startPoint;
        const end = endPoint;
        let t = 0;
        const duration = 250;
        const startTime = performance.now();

        function animate(currentTime) {
          if (!window.isAnimating) {
            if (window.currentMarker) {
              window.currentMarker.remove();
              window.currentMarker = null;
            }
            window.animationFrameId = null;
            return;
          }
          t = (currentTime - startTime) / duration;
          if (t >= 1) t = 1;

          const lat = start.lat + (end.lat - start.lat) * t;
          const lng = start.lng + (end.lng - start.lng) * t;
          if (window.currentMarker) {
            window.currentMarker.setLatLng([lat, lng]);
          }

          if (t < 1) {
            window.animationFrameId = requestAnimationFrame(animate);
          } else {
            index++;
            setTimeout(moveMarker, 0);
          }
        }

        window.animationFrameId = requestAnimationFrame(animate);
      } else {
        setTimeout(() => {
          if (window.currentMarker) {
            window.currentMarker.remove();
            window.currentMarker = null;
          }
          window.isAnimating = false;
          window.animationFrameId = null;
        }, 1000);
      }
    }

    moveMarker();
  }
  function saveTrajectory() {
    fetch("http://localhost:5000/export_experiment", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ 
          exp_id: expId 
        }),
        credentials: 'include'
    })
    .then(res => res.json())
    .then(data => {
        if (!data.success) {
            throw new Error(data.error || '导出失败');
        }
        
        // 创建并下载文件
        const blob = new Blob([data.content], { type: 'text/plain' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = data.filename;
        link.click();
        URL.revokeObjectURL(link.href);
        
        showError("currentError", "导出成功");
    })
    .catch(error => {
        console.error("保存轨迹失败:", error);
        showError("currentError", error.message || "保存轨迹失败");
    });
  }
  // function saveTrajectory() {
  //   if (!currentIds || currentIds.length === 0) {
  //     showError("currentError", "请先提交或补全轨迹");
  //     return;
  //   }

  //   fetch("http://localhost:5000/save_trajectory", {
  //     method: "POST",
  //     headers: { "Content-Type": "application/json" },
  //     body: JSON.stringify({ trajectory: currentIds })
  //   })
  //     .then(res => {
  //       if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
  //       return res.json();
  //     })
  //     .then(data => {
  //       console.log("保存轨迹成功:", data);
  //       showError("currentError", "轨迹保存成功");
  //     })
  //     .catch(error => {
  //       console.error("保存轨迹失败:", error);
  //       showError("currentError", "保存轨迹失败，请检查服务器");
  //     });
  // }
</script>
</body>
</html>